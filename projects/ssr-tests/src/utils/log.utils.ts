/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 * SPDX-FileCopyrightText: 2024 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Contains methods pertaining to reading, writing and asserting of the ssr log
 * generated by a running ssr server for the sake of testing ssr.
 */

import * as fs from 'fs';

/**
 * Path where SSR log file from server will be generated and read from.
 */
const SSR_LOG_PATH = './.ssr.log';

/**
 * Writes no characters to log to clear log file.
 */
export function clearSsrLogFile(): void {
  fs.writeFileSync(SSR_LOG_PATH, '');
}

export enum LOG_FORMAT {
  ONLY_MESSAGES = 'ONLY_MESSAGES',
  ONLY_JSON_OBJECTS = 'ONLY_JSON_OBJECTS',
  WITH_PRETTY_JSONS = 'WITH_PRETTY_JSONS',
  RAW = 'RAW',
}

export function getLogs(logFormat: LOG_FORMAT): (string | object)[] {
  const data = fs.readFileSync(SSR_LOG_PATH).toString();
  return (
    data
      .toString()
      .split('\n')
      // Try to parse JSONs:
      .map((text: any) => {
        if (text.charAt(0) === '{') {
          try {
            const object = JSON.parse(text);
            return object;
          } catch (error) {
            console.warn(
              'Encountered a line starting with `{` in logs that could not be parsed as a JSON object. Please make sure to build Spartacus SSR in prod mode - to get single line JSON logs. Dev mode would produce multi-line JSON logs that cannot be parsed.'
            );
            // If parsing fails, we return the original text.
            return text;
          }
        } else {
          // If a line is not a JSON object, we return it as is.
          // It can be anything like 'Node Express server listening on ...'
          return text;
        }
      })
      // Format parsed JSONs (but leave simple strings as is):
      .map((textOrObject: object | string) => {
        if (typeof textOrObject === 'object') {
          if (logFormat === LOG_FORMAT.WITH_PRETTY_JSONS) {
            return inspect(textOrObject, { depth: null });
          }
          if (logFormat === LOG_FORMAT.ONLY_MESSAGES) {
            return (textOrObject as { message: string }).message;
          }
          if (logFormat === LOG_FORMAT.RAW) {
            return JSON.stringify(textOrObject);
          }
          // if logFormat === LOG_FORMAT.WITH_JSONS_AS_OBJECTS:
          return textOrObject;
        } else {
          if (
            [LOG_FORMAT.ONLY_MESSAGES, LOG_FORMAT.ONLY_JSON_OBJECTS].includes(
              logFormat
            )
          ) {
            return undefined;
          }
          return textOrObject;
        }
      })
      .filter((x): x is string | object => typeof x !== 'undefined')
  );
}

/**
 * Returns only `message` property from JSON logs. Non-JSON logs are skipped.
 */
export function getLogsMessages(): string[] {
  return getLogs(LOG_FORMAT.ONLY_MESSAGES) as string[];
}

/**
 * Returns only JSON parsed as objects. Non-JSON logs are skipped.
 */
export function getLogsObjects(): object[] {
  return getLogs(LOG_FORMAT.ONLY_JSON_OBJECTS) as object[];
}

/**
 * Check log every interval to see if log contains text.
 * Keeps waiting until log contains text or test times out.
 */
export async function waitUntilLogContainsText(
  text: string,
  checkInterval = 500
): Promise<true> {
  return new Promise((resolve) => {
    if (doesLogContainText(text)) {
      return resolve(true);
    }
    return setTimeout(
      () => resolve(waitUntilLogContainsText(text)),
      checkInterval
    );
  });
}

/**
 * Returns true if log contains string.
 */
export function doesLogContainText(text: string): boolean {
  const data = fs.readFileSync(SSR_LOG_PATH).toString();
  return data.includes(text);
}

import { inspect } from 'util';
import * as LogUtils from './log.utils';

/**
 * A higher-order function that wraps a test callback and includes SSR logs
 * in any error thrown during the test execution. The logs are put into the `cause`
 * property of the Error.
 *
 * @param testFn - The original test function to be wrapped.
 * @returns A new function that can be passed to Jest's `it()` or `test()`.
 *
 * @example
 * it('should perform SSR correctly', attachLogsToErrors(async () => {
 *   // Your test code here
 * }));
 */
export function attachLogsToErrors(
  testFn: () => Promise<void> | void
): () => Promise<void> {
  return async () => {
    try {
      await testFn();
    } catch (error: unknown) {
      const readableLogs = LogUtils.getLogs(
        LogUtils.LOG_FORMAT.WITH_PRETTY_JSONS
      ).join('\n');
      const ssrLogs = `(more context below)\n--- SSR LOGS (with JSONs pretty-printed) ---\n${readableLogs}\n--- SSR LOGS END ---`;

      if (error instanceof Error) {
        // Error's `cause` property is the only property printed by Jest
        // besides `message` that we can utilize for attaching logs.
        // No other custom properties are printed by Jest.
        // See their source code of their function `formatExecError`:
        // https://github.com/jestjs/jest/blob/bd1c6db7c15c23788ca3e09c919138e48dd3b28a/packages/jest-message-util/src/index.ts#L235
        error.cause = ssrLogs;
      } else {
        throw new Error(error as string, { cause: ssrLogs });
      }

      throw error;
    }
  };
}
