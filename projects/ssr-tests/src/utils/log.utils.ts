/*
 * SPDX-FileCopyrightText: 2023 SAP Spartacus team <spartacus-team@sap.com>
 * SPDX-FileCopyrightText: 2024 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * Contains methods pertaining to reading, writing and asserting of the ssr log
 * generated by a running ssr server for the sake of testing ssr.
 */

import * as fs from 'fs';
import { inspect } from 'util';

/**
 * Path where SSR log file from server will be generated and read from.
 */
const SSR_LOG_PATH = './.ssr.log';

/**
 * Writes no characters to log to clear log file.
 */
export function clearSsrLogFile(): void {
  fs.writeFileSync(SSR_LOG_PATH, '');
}

/**
 * Validates that all lines starting with `{` are valid JSON objects.
 * Otherwise it warns.
 *
 * Note: multi-line JSONs (printed by SSR in dev mode) cannot be parsed by `JSON.parse`.
 *       That's why we need to to run SSR in prod mode to get single line JSON logs.
 */
function validateJsonsInLogs(rawLogs: string[]): void {
  for (const logLine of rawLogs) {
    if (logLine.charAt(0) === '{') {
      try {
        JSON.parse(logLine);
      } catch (_e) {
        const surroundingLinesRadius = 2;
        const surroundingLines = getSurroundingLines({
          allLines: rawLogs,
          line: logLine,
          radius: surroundingLinesRadius,
        });

        console.warn(
          `
          Encountered in SSR Logs a line starting with \`{\` that could not be parsed as JSON.
          Perhaps its a multi-line JSON log from SSR dev mode.
          Please make sure to build Spartacus SSR in prod mode prior to running SSR Tests
          to get single line JSONs that can be parsed in tests.
          
          For specific context, see ${surroundingLinesRadius * 2 + 1} raw log lines below (previous ${surroundingLinesRadius} lines, current line, next ${surroundingLinesRadius} lines):
\`\`\`
${surroundingLines.join('\n')}
\`\`\`
`
        );
        break;
      }
    }
  }
}

/**
 * Returns the given line with surrounding lines.
 * e.g. if the radius is 2, the function will return the given line
 * and the 2 lines before and 2 lines after it. In other words, it returns an array of 5 lines.
 */
function getSurroundingLines({
  allLines,
  line,
  radius,
}: {
  allLines: string[];
  line: string;
  radius: number;
}): string[] {
  const logLineIndex = allLines.indexOf(line);
  const surroundingStartIndex = Math.max(0, logLineIndex - radius);
  const surroundingEndIndex = Math.min(
    allLines.length,
    logLineIndex + radius + 1
  );
  return allLines.slice(surroundingStartIndex, surroundingEndIndex);
}

/**
 * Returns raw logs as an array of strings.
 *
 * Note: Non-JSON log entries are also included in the returned array.
 *
 * It also validates whether each line starting with `{` is a valid JSON object.
 * Otherwise it throws an error.
 */
export function getRawLogs(): string[] {
  const data = fs.readFileSync(SSR_LOG_PATH).toString();
  const logs = data.toString().split('\n');
  validateJsonsInLogs(logs);
  return logs;
}

/**
 * Returns raw logs as an array of strings, with JSON objects pretty-printed.
 *
 * Note: Non-JSON log entries are also included in the returned array.
 */
export function getRawLogsPretty(): string[] {
  return getRawLogs().map((line) => {
    try {
      const object = JSON.parse(line);
      return inspect(object, { depth: null });
    } catch (_e) {
      // If the line is not a valid JSON, return it as a string
      return line;
    }
  });
}

/**
 * Returns logs as an array of objects, parsed from JSON log entries.
 *
 * Note: Non-JSON log entries are skipped (e.g. 'Node is running on port 4000').
 */
export function getLogsObjects(): object[] {
  return getRawLogs()
    .map((log) => {
      try {
        return JSON.parse(log);
      } catch (_e) {
        return undefined;
      }
    })
    .filter((x): x is object => x !== undefined);
}

/**
 * Returns logs as an array of strings, being the `message` field of each parsed JSON log entry.
 *
 * Note: Non-JSON log entries are skipped (e.g. 'Node is running on port 4000').
 */
export function getLogsMessages(): string[] {
  return getLogsObjects().map((log) => {
    return (log as { message: string }).message;
  });
}

/**
 * Check log every interval to see if log contains text.
 * Keeps waiting until log contains text or test times out.
 */
export async function waitUntilLogContainsText(
  text: string,
  checkInterval = 500
): Promise<true> {
  return new Promise((resolve) => {
    if (getRawLogs().some((log) => log.includes(text))) {
      return resolve(true);
    }
    return setTimeout(
      () => resolve(waitUntilLogContainsText(text)),
      checkInterval
    );
  });
}
